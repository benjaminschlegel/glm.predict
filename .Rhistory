check()
checkCRAN()
devtools::release()
spell_check()
spell_check()
devtools::release()
system("R CMD check")
system("R CMD check ../")
system("R CMD check")
system("R CMD check ../glm.predict")
system("R CMD check ../glm.predict")
system("R CMD check ../glm.predict")
system("R CMD check ../glm.predict")
?survival::coxph
?survey::svycoxph
system("R CMD check ../glm.predict --as-cran")
?bibentry
as.person("Benjamin E. Schlegel")
person("Benjamin E. Schlegel")
library(devtools)
system("R CMD check ../glm.predict --as-cran")
devtools::build_vignettes()
system("R CMD check ../glm.predict --as-cran")
devtools::build_vignettes()
system("R CMD check ../glm.predict --as-cran")
use_vignette("predicts")
browseVignettes()
system("R CMD check ../glm.predict --as-cran")
library(glm.predict)
install(build_vignettes = TRUE)
unloadNamespace("htmltools")
unloadNamespace("rmarkdown")
unloadNamespace("shiny")
unloadNamespace("miniUI")
install.packages("htmltools")
install.packages("htmltools")
install(build_vignettes = TRUE)
devtools::install(build_vignettes = TRUE)
install.packages("vctrs")
install.packages("vctrs")
unloadNamespace("vctrs")
install.packages("vctrs")
devtools::install(build_vignettes = TRUE)
warnings()
unloadNamespace("stringi")
unloadNamespace("stringr")
system("R CMD check ../glm.predict --as-cran")
library(devtools)
build_vignettes()
system("R CMD check ../glm.predict --as-cran")
system("R CMD check ../glm.predict --as-cran")
check()
check()
devtools::build_rmd("vignettes/glm.predict.Rmd")
build_vignettes("glm.predict")
build_vignettes()
browseVignettes("glm.predict")
check()
devtools::submit_cran()
devtools::release()
system("R CMD check")
system("R CMD check ../glm.predict")
setwd("..")
getwd
getwd()
system("R CMD check glm.predict")
setwd("glm.predict")
use_git()
use_git()
setwd("..")
system("R CMD check glm.predict --as-cran")
system("R CMD check glm.predict --as-cran")
system("R CMD built glm.predict")
system("R CMD build glm.predict")
system("R CMD check glm.predict_4.3-0.tar.gz --as-cran")
install.packages("pandoc")
system("R CMD check glm.predict_4.3-0.tar.gz --as-cran")
install.packages("pandoc")
system("R CMD check glm.predict_4.3-0.tar.gz --as-cran")
devtools::release()
setwd("glm.predict")
devtools::release()
check_rhub()
devtools::release()
check_win_devel()
devtools::release()
use_cran_comments()
devtools::release()
library(devtools)
release()
release()
install.packages("newsmd")
library(newsmd)
my_news = news$new()
my_news
my_news$add_version("4.3-0")
my_news
my_news$add_bullet(c("Added support for generalized ordinal logit with vglm()", "added vignette"))
my_news
my_news$write()
check()
spell_check()
release()
library(glm.predict)
glm.predict:::getFactorCombinations(3)
glm.predict:::getFactorCombinations(5)
position = NULL
a = sample(LETTERS[1:3], 100, replace = TRUE)
a
a = factor(a, levels = LETTERS[1:4])
a
table(a)
df = data.frame(x = a, y = rnorm(100))
df
df$x
model = lm(y ~ x, data = df)
model
summary(model)
data =  stats::model.frame(model)
data
values = "3"
position
glm.predict:::initialize_data.frame(data, position)
result = glm.predict:::initialize_data.frame(data, position)
log.pos = result$log.pos # at which positions are logarithms?
result = result$result
result
value = glm.predict:::getValues(values, data)
value
# get base combinations
char_pos = which(sapply(full_data, is.character))
# get base combinations
char_pos = which(sapply(data, is.character))
char_pos
# data = full_data[,-1]  # data without y
matrix = stats::model.matrix(model)
matrix
# get values from character
value = getValues(values, data)
values.list = value[[1]]
is.factor = value[[2]]
values.list
is.factor
products = getProducts(value, position)
products = glm.predict:::getProducts(value, position)
products
# initialize variables
n = length(values.list)
n
rows = products[length(products)]
rows
cnames = colnames(matrix)
cnames
value.names = grep("^[^(][^:\\^]*$",cnames, value = T)
value.names
base.combinations = matrix(NA, nrow = rows, ncol = length(value.names))
base.combinations
colnames(base.combinations) = value.names
base.combinations
for(r in 1:rows){
if(is.null(position)){
data.frame.position = length(result) - n + 1
}else{
data.frame.position = length(result) - n
}
c = 1
for(i in 1:n){
current.product = products[i]
current.values = values.list[[i]]
if(i == 1){
preproduct = 1
}else{
preproduct = products[i-1]
}
v1 = floor((r - 1) %% current.product / preproduct) + 1
if(!is.null(position) && i == position && is.factor[i]){
combinations = getFactorCombinations(length(current.values[,1]))
f.v1 = combinations[v1,1]
f.v2 = combinations[v1,2]
base.combinations_1[r,c:(c + length(current.values[f.v1,]) - 1)] = current.values[f.v1,]
base.combinations_2[r,c:(c + length(current.values[f.v1,]) - 1)] = current.values[f.v2,]
# labels
label_pos1 = which(current.values[f.v1,]==1)
label_pos2 = which(current.values[f.v2,]==1)
label_pos1 = ifelse(length(label_pos1) == 0, 1, label_pos1 + 1)
label_pos2 = ifelse(length(label_pos2) == 0, 1, label_pos2 + 1)
result[r, data.frame.position] = getLabel(data, i, label_pos1)
result[r, data.frame.position + 1] = getLabel(data, i, label_pos2)
data.frame.position = data.frame.position + 2
c = c + length(current.values[f.v1,])
}else if(!is.null(position) && i == position){
v2 = v1 + 1
base.combinations_1[r,c:(c + length(current.values[v1]) - 1)] = current.values[v1]
base.combinations_2[r,c:(c + length(current.values[v1]) - 1)] = current.values[v2]
# labels
result[r,data.frame.position] = current.values[v1]
result[r,data.frame.position+1] = current.values[v2]
data.frame.position = data.frame.position + 2
c = c + length(current.values[v1])
}else if(is.factor[i]){
if(is.null(position)){
base.combinations[r,c:(c + length(current.values[v1,]) - 1)] = current.values[v1,]
}else{
base.combinations_1[r,c:(c + length(current.values[v1,]) - 1)] = current.values[v1,]
base.combinations_2[r,c:(c + length(current.values[v1,]) - 1)] = current.values[v1,]
}
c = c + length(current.values[v1,])
# labels
pos = 1
for(p in 1:length(current.values[v1,])){
if(current.values[v1,][p]==1){
pos = p + 1
}
}
result[r, data.frame.position] = getLabel(data,i,pos)
data.frame.position = data.frame.position + 1
}else{
if(is.null(position)){
base.combinations[r, c] = current.values[v1]
}else{
base.combinations_1[r, c] = current.values[v1]
base.combinations_2[r, c] = current.values[v1]
}
# labels
if(data.frame.position %in% log.pos){
result[r, data.frame.position] = exp(current.values[v1])
}else{
result[r, data.frame.position] = current.values[v1]
}
data.frame.position = data.frame.position + 1
c = c + 1
}
}
}
rows
r = 1
is.null(position)
data.frame.position = length(result) - n + 1
data.frame.position
c = 1
for(i in 1:n){
current.product = products[i]
current.values = values.list[[i]]
if(i == 1){
preproduct = 1
}else{
preproduct = products[i-1]
}
v1 = floor((r - 1) %% current.product / preproduct) + 1
if(!is.null(position) && i == position && is.factor[i]){
combinations = getFactorCombinations(length(current.values[,1]))
f.v1 = combinations[v1,1]
f.v2 = combinations[v1,2]
base.combinations_1[r,c:(c + length(current.values[f.v1,]) - 1)] = current.values[f.v1,]
base.combinations_2[r,c:(c + length(current.values[f.v1,]) - 1)] = current.values[f.v2,]
# labels
label_pos1 = which(current.values[f.v1,]==1)
label_pos2 = which(current.values[f.v2,]==1)
label_pos1 = ifelse(length(label_pos1) == 0, 1, label_pos1 + 1)
label_pos2 = ifelse(length(label_pos2) == 0, 1, label_pos2 + 1)
result[r, data.frame.position] = getLabel(data, i, label_pos1)
result[r, data.frame.position + 1] = getLabel(data, i, label_pos2)
data.frame.position = data.frame.position + 2
c = c + length(current.values[f.v1,])
}else if(!is.null(position) && i == position){
v2 = v1 + 1
base.combinations_1[r,c:(c + length(current.values[v1]) - 1)] = current.values[v1]
base.combinations_2[r,c:(c + length(current.values[v1]) - 1)] = current.values[v2]
# labels
result[r,data.frame.position] = current.values[v1]
result[r,data.frame.position+1] = current.values[v2]
data.frame.position = data.frame.position + 2
c = c + length(current.values[v1])
}else if(is.factor[i]){
if(is.null(position)){
base.combinations[r,c:(c + length(current.values[v1,]) - 1)] = current.values[v1,]
}else{
base.combinations_1[r,c:(c + length(current.values[v1,]) - 1)] = current.values[v1,]
base.combinations_2[r,c:(c + length(current.values[v1,]) - 1)] = current.values[v1,]
}
c = c + length(current.values[v1,])
# labels
pos = 1
for(p in 1:length(current.values[v1,])){
if(current.values[v1,][p]==1){
pos = p + 1
}
}
result[r, data.frame.position] = getLabel(data,i,pos)
data.frame.position = data.frame.position + 1
}else{
if(is.null(position)){
base.combinations[r, c] = current.values[v1]
}else{
base.combinations_1[r, c] = current.values[v1]
base.combinations_2[r, c] = current.values[v1]
}
# labels
if(data.frame.position %in% log.pos){
result[r, data.frame.position] = exp(current.values[v1])
}else{
result[r, data.frame.position] = current.values[v1]
}
data.frame.position = data.frame.position + 1
c = c + 1
}
}
1:n
i = 1
current.product = products[i]
current.values = values.list[[i]]
current.product
current.values
i == 1
if(i == 1){
preproduct = 1
}else{
preproduct = products[i-1]
}
v1 = floor((r - 1) %% current.product / preproduct) + 1
v1
!is.null(position) && i == position && is.factor[i]
!is.null(position) && i == position
is.factor[i]
is.null(position)
base.combinations[r,c:(c + length(current.values[v1,]) - 1)] = current.values[v1,]
base.combinations
v1
current.values
current.values[v1,]
base.combinations[r,c:(c + length(current.values[v1,]) - 1)]
current.values[v1,]
c:(c + length(current.values[v1,]) - 1)
base.combinations
c = 1
i
current.product = products[i]
current.values = values.list[[i]]
if(i == 1){
preproduct = 1
}else{
preproduct = products[i-1]
}
v1 = floor((r - 1) %% current.product / preproduct) + 1
if(!is.null(position) && i == position && is.factor[i]){
combinations = getFactorCombinations(length(current.values[,1]))
f.v1 = combinations[v1,1]
f.v2 = combinations[v1,2]
base.combinations_1[r,c:(c + length(current.values[f.v1,]) - 1)] = current.values[f.v1,]
base.combinations_2[r,c:(c + length(current.values[f.v1,]) - 1)] = current.values[f.v2,]
# labels
label_pos1 = which(current.values[f.v1,]==1)
label_pos2 = which(current.values[f.v2,]==1)
label_pos1 = ifelse(length(label_pos1) == 0, 1, label_pos1 + 1)
label_pos2 = ifelse(length(label_pos2) == 0, 1, label_pos2 + 1)
result[r, data.frame.position] = getLabel(data, i, label_pos1)
result[r, data.frame.position + 1] = getLabel(data, i, label_pos2)
data.frame.position = data.frame.position + 2
c = c + length(current.values[f.v1,])
}else if(!is.null(position) && i == position){
v2 = v1 + 1
base.combinations_1[r,c:(c + length(current.values[v1]) - 1)] = current.values[v1]
base.combinations_2[r,c:(c + length(current.values[v1]) - 1)] = current.values[v2]
# labels
result[r,data.frame.position] = current.values[v1]
result[r,data.frame.position+1] = current.values[v2]
data.frame.position = data.frame.position + 2
c = c + length(current.values[v1])
}else if(is.factor[i]){
if(is.null(position)){
base.combinations[r,c:(c + length(current.values[v1,]) - 1)] = current.values[v1,]
}else{
base.combinations_1[r,c:(c + length(current.values[v1,]) - 1)] = current.values[v1,]
base.combinations_2[r,c:(c + length(current.values[v1,]) - 1)] = current.values[v1,]
}
c = c + length(current.values[v1,])
# labels
pos = 1
for(p in 1:length(current.values[v1,])){
if(current.values[v1,][p]==1){
pos = p + 1
}
}
result[r, data.frame.position] = getLabel(data,i,pos)
data.frame.position = data.frame.position + 1
}else{
if(is.null(position)){
base.combinations[r, c] = current.values[v1]
}else{
base.combinations_1[r, c] = current.values[v1]
base.combinations_2[r, c] = current.values[v1]
}
# labels
if(data.frame.position %in% log.pos){
result[r, data.frame.position] = exp(current.values[v1])
}else{
result[r, data.frame.position] = current.values[v1]
}
data.frame.position = data.frame.position + 1
c = c + 1
}
c
c = 1
is.factor[i]
is.null(position)
base.combinations[r,c:(c + length(current.values[v1,]) - 1)] = current.values[v1,]
base.combinations
c = c + length(current.values[v1,])
c
# labels
pos = 1
for(p in 1:length(current.values[v1,])){
if(current.values[v1,][p]==1){
pos = p + 1
}
}
p
pos
result[r, data.frame.position] = glm.predict:::getLabel(data,i,pos)
glm.predict:::getLabel(data,i,pos)
result[r, data.frame.position]
data.frame.position = data.frame.position + 1
temp = glm.predict:::getBaseCombinations(full_data, matrix, values, model, dv_levels, position)
if(!is.character(values)){
stop("values must be given as character!")
}
if("vglm" %in% class(model)){
full_data = VGAM::model.frame(model)
}else{
full_data =  stats::model.frame(model)
}
if(any(c("lmerMod", "glmerMod") %in% class(model))){
full_data = full_data[,-which(colnames(full_data) %in% names(ranef(model)))]
}
# collapse values to one character, if given as vector
if(length(values) > 1){
values = paste(values, collapse = ";")
}
if("tobit" %in% class(model)){
colnames(full_data)[1] = "y"
}
# reshape mlogit data
if("dfidx" %in% class(full_data)){
choices = levels(full_data$idx[[2]])
full_data = as.data.frame(full_data)
pos_idx = which(colnames(full_data) == "idx")
full_data = full_data[, -(pos_idx:ncol(full_data))]
full_data[,1] = as.factor(choices)
}
# remove weights column
if("(weights)" %in% colnames(full_data)){
full_data = full_data[,-which(colnames(full_data) == "(weights)")]
}
# remove polynomial values
full_data = full_data[, grep("^[^(][^:\\^]*$", colnames(full_data), value = TRUE)]
if(length(unlist(strsplit(values, ";"))) != ncol(full_data) - 1){
stop("The length of values does not match the number of independend variables.")
}
if(!is.null(position) && (!is.numeric(position) || position != round(position))){
stop("position must be a whole number or NULL.")
}
if(inherits(model, "multinom") && doPar){
doPar = FALSE
warning("Parallel version not supported for multinom() models. Setting doPar to FALSE.")
}
type = match.arg(type)
type = "simulation"
# remove any empty space in values
values = gsub("\\s","",values)
# get data
if(inherits(model,"polr") || inherits(model,"multinom") || inherits(model, "mlogit")){
if(!is.null(levels(full_data[,1]))){
dv_levels = levels(full_data[,1])
}else{
dv_levels = levels(as.factor(full_data[, 1]))
}
}else if(inherits(model,"vglm")){
dv_levels = model@extra$colnames.y
}else{
dv_levels = NULL
}
# data = full_data[,-1]  # data without y
matrix = stats::model.matrix(model)
# get base combinations
char_pos = which(sapply(full_data, is.character))
for(i in char_pos){
full_data[,i] = as.factor(full_data[,i])
}
temp = glm.predict:::getBaseCombinations(full_data, matrix, values, model, dv_levels, position)
temp
result = temp[["result"]]
if(is.null(position)){
base.combinations = temp[["base.combinations"]]
}else{
base.combinations_1 = temp[["base.combinations_1"]]
base.combinations_2 = temp[["base.combinations_2"]]
}
base.combinations
combinations = glm.predict:::getCombinations(matrix, base.combinations, model, dv_levels)
combinations
model = glm(participation ~ age * gender, data =schlegel::selects2015)
glm.predict::predicts(model, "18;0")
glm.predict::predicts(model, "18;1")
library(devtools)
install()
devtools::load_all()
predicts(model, "18;0")
devtools::load_all()
predicts(model, "18;0")
predicts(model, "18:10")
predicts(model, "18:20,1")
predicts(model, "18:20;1")
