library(glm.predict)
predicts
getbaseCombinations
glm.predict:::getBaseCombinations
rep(1:10, times = 3)
rep(1:10, each = 3)
num_i = 1:10
rep_i = rep(50, 10)
num_i = rep(num_i, times = rep_i)
num_i
basepredict.lmer = function(model, values, sim.count = 1000, conf.int = 0.95, sigma = NULL, set.seed = NULL,
type = c("any", "simulation", "bootstrap"), summary = TRUE){
# check inputs
if(sum("lmerMod" %in% class(model)) == 0){
stop("model has to be of type lmer()")
}
if(length(values) != length(fixef(model))){
stop("the length of values is not identical to the number of coefficient of the model")
}
if(!is.numeric(sim.count) | round(sim.count) != sim.count){
stop("sim.count has to be a whole number")
}
if(!is.numeric(conf.int)){
stop("conf.int has to be numeric")
}
if(!is.null(set.seed) & !is.numeric(set.seed)){
stop("set.seed must be numeric")
}
type = match.arg(type)
if(type == "any"){
if(nrow(model.frame(model)) < 500){
type = "bootstrap"
message("Type not specified: Using bootstrap as n < 500")
}else{
type = "simulation"
message("Type not specified: Using simulation as n >= 500")
}
}
if(type == "simulation"){
if(is.null(sigma)){
sigma = stats::vcov(model)
}
if(nrow(sigma) != length(values)){
warning("sigma and values do not match, ignoring the specified sigma")
sigma = stats::vcov(model)
}
if(!is.null(set.seed)){
set.seed(set.seed)
}
betas_sim = MASS::mvrnorm(sim.count, fixef(model), sigma)
# get the predicted probabilities/values with the inverse link function
pred = betas_sim %*% values
}else{ # bootstrap
boot = function(x, model){
data = model.frame(model)
sample_data = data[sample(seq_len(nrow(data)), replace = TRUE), ]
fixef(update(model, data = sample_data))
}
betas_boot = do.call('rbind', lapply(seq_len(sim.count), boot, model))
# get the predicted probabilities/values with the inverse link function
pred = betas_boot %*% values
}
# return all simulated / bootstrapped values if summary is FALSE
if(!summary){
return(pred)
}
# calculate mean and confident interval
confint_lower = (1 - conf.int) / 2
result = t(as.matrix(c(mean(pred, na.rm = TRUE),
quantile(pred, c(confint_lower, 1 - confint_lower), na.rm = TRUE))))
# name the output matrix
colnames(result) = c("Mean",
paste0(100 * confint_lower,"%"),
paste0(100 * (1 - confint_lower),"%"))
result
}
model1 = lmer(lr_self ~ age + gender + (1 | canton), data=selects2015)
library(lne4)
library(lme4)
model1 = lmer(lr_self ~ age + gender + (1 | canton), data=selects2015)
library(glm.predict)
model1 = lmer(lr_self ~ age + gender + (1 | canton), data=selects2015)
basepredict(model1, c(1,18,1))
basepredict.lmerMod = function(model, values, sim.count = 1000, conf.int = 0.95, sigma = NULL, set.seed = NULL,
type = c("any", "simulation", "bootstrap"), summary = TRUE){
# check inputs
if(sum("lmerMod" %in% class(model)) == 0){
stop("model has to be of type lmer()")
}
if(length(values) != length(fixef(model))){
stop("the length of values is not identical to the number of coefficient of the model")
}
if(!is.numeric(sim.count) | round(sim.count) != sim.count){
stop("sim.count has to be a whole number")
}
if(!is.numeric(conf.int)){
stop("conf.int has to be numeric")
}
if(!is.null(set.seed) & !is.numeric(set.seed)){
stop("set.seed must be numeric")
}
type = match.arg(type)
if(type == "any"){
if(nrow(model.frame(model)) < 500){
type = "bootstrap"
message("Type not specified: Using bootstrap as n < 500")
}else{
type = "simulation"
message("Type not specified: Using simulation as n >= 500")
}
}
if(type == "simulation"){
if(is.null(sigma)){
sigma = stats::vcov(model)
}
if(nrow(sigma) != length(values)){
warning("sigma and values do not match, ignoring the specified sigma")
sigma = stats::vcov(model)
}
if(!is.null(set.seed)){
set.seed(set.seed)
}
betas_sim = MASS::mvrnorm(sim.count, fixef(model), sigma)
# get the predicted probabilities/values with the inverse link function
pred = betas_sim %*% values
}else{ # bootstrap
boot = function(x, model){
data = model.frame(model)
sample_data = data[sample(seq_len(nrow(data)), replace = TRUE), ]
fixef(update(model, data = sample_data))
}
betas_boot = do.call('rbind', lapply(seq_len(sim.count), boot, model))
# get the predicted probabilities/values with the inverse link function
pred = betas_boot %*% values
}
# return all simulated / bootstrapped values if summary is FALSE
if(!summary){
return(pred)
}
# calculate mean and confident interval
confint_lower = (1 - conf.int) / 2
result = t(as.matrix(c(mean(pred, na.rm = TRUE),
quantile(pred, c(confint_lower, 1 - confint_lower), na.rm = TRUE))))
# name the output matrix
colnames(result) = c("Mean",
paste0(100 * confint_lower,"%"),
paste0(100 * (1 - confint_lower),"%"))
result
}
basepredict(model1, c(1,18,1))
model = model1
library(lme4)
model = lmer(lr_self ~ age + gender + (1 | canton), data = schlegel::selects2015)
values = "F;18-32"
if(!is.character(values)){
stop("values must be given as character!")
}
full_data = stats::model.frame(model)
full_data
# collapse values to one character, if given as vector
if(length(values) > 1){
values = paste(values, collapse = ";")
}
# reshape mlogit data
if("dfidx" %in% class(full_data)){
choices = levels(full_data$idx[[2]])
full_data = as.data.frame(full_data)
pos_idx = which(colnames(full_data) == "idx")
full_data = full_data[, -(pos_idx:ncol(full_data))]
full_data[,1] = as.factor(choices)
}
# remove weights column
if("(weights)" %in% colnames(full_data)){
full_data = full_data[,-which(colnames(full_data) == "(weights)")]
}
# remove polynomial values
full_data = full_data[, grep("^[^(][^:\\^]*$", colnames(full_data), value = T)]
if(length(unlist(strsplit(values, ";"))) != ncol(full_data) - 1){
stop("The length of values does not match the number of independend variables.")
}
ncol(full_data)
"merMod" %in% class(model))
"merMod" %in% class(model)
class(model)
("lmerMod", "glmerMod") %in% class(model)
c("lmerMod", "glmerMod") %in% class(model)
ny(c("lmerMod", "glmerMod") %in% class(model))
any(c("lmerMod", "glmerMod") %in% class(model))
coef(model)
fixef(model)
length(unlist(strsplit(values, ";")))
ncol(full_data) - 1
model@resp
model@flist
model@pp
model@call
model@call$formula
unlist(model@call$formula)
model@call$formula[[2]]
model@call$formula[[1]]
model@call$formula[[3]]
model@Gp
model@cnms
model@lower
vcov(model)
sigma(model)
isNested(model)
model@call$formula
model@Gp
group(model)
fixef(model)
ranef(model)
names(ranef(model))
model = lmer(lr_self ~ age + gender + (1 | canton) + (1 | education), data = schlegel::selects2015)
names(ranef(model))
model = lmer(lr_self ~ age + gender + (1 | canton), data = schlegel::selects2015)
names(ranef(model))
full_data[,-names(ranef(model))]
names(ranef(model))
which(colnames(full_data) %in% names(ranef(model)))
full_data = stats::model.frame(model)
if(){
full_data = full_data[,-which(colnames(full_data) %in% names(ranef(model)))]
}
full_data = stats::model.frame(model)
if(any(c("lmerMod", "glmerMod") %in% class(model))){
full_data = full_data[,-which(colnames(full_data) %in% names(ranef(model)))]
}
full_data
# collapse values to one character, if given as vector
if(length(values) > 1){
values = paste(values, collapse = ";")
}
# reshape mlogit data
if("dfidx" %in% class(full_data)){
choices = levels(full_data$idx[[2]])
full_data = as.data.frame(full_data)
pos_idx = which(colnames(full_data) == "idx")
full_data = full_data[, -(pos_idx:ncol(full_data))]
full_data[,1] = as.factor(choices)
}
# remove weights column
if("(weights)" %in% colnames(full_data)){
full_data = full_data[,-which(colnames(full_data) == "(weights)")]
}
# remove polynomial values
full_data = full_data[, grep("^[^(][^:\\^]*$", colnames(full_data), value = T)]
if(length(unlist(strsplit(values, ";"))) != ncol(full_data) - 1){
stop("The length of values does not match the number of independend variables.")
}
if(!is.null(position) && (!is.numeric(position) || position != round(position))){
stop("position must be a whole number or NULL.")
}
position = NULL
if(!is.null(position) && (!is.numeric(position) || position != round(position))){
stop("position must be a whole number or NULL.")
}
if(inherits(model, "multinom")){
doPar = F
}
type = match.arg(type)
type = "simulation"
# remove any empty space in values
values = gsub("\\s","",values)
# get data
if(inherits(model,"polr") || inherits(model,"multinom") || inherits(model, "mlogit")){
if(!is.null(levels(full_data[,1]))){
dv_levels = levels(full_data[,1])
}else{
dv_levels = levels(as.factor(full_data[, 1]))
}
}else{
dv_levels = NULL
}
# data = full_data[,-1]  # data without y
matrix = stats::model.matrix(model)
# get base combinations
char_pos = which(sapply(full_data, is.character))
for(i in char_pos){
full_data[,i] = as.factor(full_data[,i])
}
temp = getBaseCombinations(full_data, matrix, values, model, dv_levels, position)
result = temp[["result"]]
temp = glm.predict:::getBaseCombinations(full_data, matrix, values, model, dv_levels, position)
values
values = "18-32;F"
temp = glm.predict:::getBaseCombinations(full_data, matrix, values, model, dv_levels, position)
temp = getBaseCombinations(full_data, matrix, values, model, dv_levels, position)
result = temp[["result"]]
if(is.null(position)){
base.combinations = temp[["base.combinations"]]
}else{
base.combinations_1 = temp[["base.combinations_1"]]
base.combinations_2 = temp[["base.combinations_2"]]
}
# add other things to base combinations
if(is.null(position)){
combinations = glm.predict:::getCombinations(matrix, base.combinations, model, dv_levels)
}else{
combinations_1 = getCombinations(matrix, base.combinations_1, model, dv_levels)
combinations_2 = getCombinations(matrix, base.combinations_2, model, dv_levels)
}
# simulate
if(is.null(position)){
if(is.null(dv_levels)){
result[, 1:3] = t(apply(combinations, 1, basepredict, model = model, sim.count = sim.count, conf.int = conf.int, sigma = sigma, set.seed = set.seed, type = type))
}else{
temp = apply(combinations, 1, basepredict, model = model, sim.count = sim.count, conf.int = conf.int, sigma = sigma, set.seed = set.seed, type = type)
result[, 1:3] = t(do.call(rbind,lapply(1:3, getResultMatrix, result_matrix = temp, levels = length(dv_levels), base.combinations = base.combinations)))
}
}else{
combinations = cbind(combinations_1,combinations_2)
if(is.null(dv_levels)){
result[, 1:9] = t(apply(combinations, 1, dc, model = model, sim.count = sim.count, conf.int = conf.int, sigma = sigma, set.seed = set.seed, type = type))
result[,  c("val1_lower", "val1_upper", "val2_mean", "val2_upper", "dc_mean", "dc_lower")] =
result[,  c("val2_mean", "dc_mean", "val1_lower", "dc_lower", "val1_upper", "val2_upper")]
}else{
temp = apply(combinations, 1, dc, model = model, sim.count = sim.count, conf.int = conf.int, sigma = sigma, set.seed = set.seed, type = type)
result[, 1:9] = t(do.call(rbind,lapply(1:9, getResultMatrix, result_matrix = temp, levels = length(dv_levels), base.combinations = base.combinations_1)))
}
}
